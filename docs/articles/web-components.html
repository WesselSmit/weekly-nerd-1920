<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href='https://fonts.googleapis.com/css?family=Quicksand' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" href="../styles/detail.css" type="text/css">
	<title>Web Components</title>
</head>

<body>
	<header>
		<a id="back-button" href="../index.html"><span></span></a>

		<h1>Web Components</h1>
		<h4>Custom Elements, Shadow DOM and HTML Templates</h4>
	</header>

	<main>
		<section>
			<h2>What are Web Components?</h2>

			<p>Using multiple web API's and technologies you can create create custom, reusable, encapsulated HTML tags,
				these are called web components (WC). If you are familiar with HTML you know the language consists of
				<a href="https://www.w3schools.com/tags/default.asp" target="=_blank">tags</a>. All tags have their own
				uses, behaviour and can differ in basic styling.</p>

			<p>All the relied upon API's and technologies can also be used individually, they all have their own unique
				use-cases.</p>

			<p>In HTML you can also create your own tags by wrapping it in tags, for example;
				&lt;test&gt; or &lt;example&gt;. These 'custom' elements all function the same because undewater they
				are actually span tags/elements.</p>

			<q>&lt;example&gt; is more like a semi-custom element; it has it's own tag but behaves and looks like a
				&lt;span&gt; element. Custom Elements are defined in JS and can then be used in HTML.</q>

			<p>Web Components allows us to create custom elements and assign markup, styling and behaviour. This way
				your custom elements have markup, a basic styling and behaviour without stylesheets or scripts.</p>
		</section>

		<section>
			<h2>Drawing a comparison from Web Components to HTML</h2>

			<p>WC are essentially custom defined HTMl tags which come with their own standard styling and behaviour.
				This basic styling is defined in the code where the WC is created.</p>

			<p>You could look at standard HTMl tags as custom elements defined by the W3C.</p>

			<p>Take the &lt;h2&gt; element for example. Without applying custom CSS rules or scripting it's: black,
				bold, has a custom font-size and custom margin.</p>

			<p>The &lt;video&gt; element also has custom attributes such as: autoplay, controls, loop, muted, poster and
				preload. What these attributes do, how they work etcetera is all defined somewhere but it's not
				accessible for us developers (we can only overwrite it if necessary).</p>
		</section>

		<section>
			<h2>Advantages of Web Components</h2>

			<ul>
				<li>WC can be reused as much as you want to, you only have to define them once.</li>
				<li>WC code/logic is encapsulated, it uses a private scope which means it isn't accessible in the global
					scope/DOM.</li>
				<li>WC only require basic HTML, CSS and JS. It's future proof and compatible with frameworks.</li>
			</ul>

			<ul>
				<p>WC also improve the maintenance and readability of your code;</p>

				<li>Code and logic is contained in one area. Apps are compartmentalized into smaller chunks instead of
					one big file.</li>
				<li>Custom elements allow for custom tag names, which makes it easier to read HTML and determine
					which element does what:</li>
			</ul>

			<div class="code">
				<p>&lt;div id="image-carousel"&gt;&lt;/div&gt; <span>//Standard HTML</span></p>

				<p><span>//Is better readable as:</span></p>

				<p>&lt;image-carousel&gt;&lt;/image-carousel&gt; <span>//Custom Element</span></p>
			</div>

		</section>

		<section>
			<h2>The Web Component building blocks</h2>

			<p>As mentioned before, WC rely on a few web API's and technologies. All these API's and technologies can
				be used on their own (and have their own use-cases) but when used together they create web components.
			</p>
		</section>

		<section>
			<h2>Custom Elements</h2>

			<p>Custom Elements are HTML tags defined by you. You can name them, give them custom markup, styling and
				scripts.</p>

			<p>to create a basic custom element you need atleast HTML and JS.</p>

			<p>In the HTML you need to insert your custom element.</p>

			<q>NOTE: all custom elements need to contain a dash (-) in their name. This is for the parser to indicate
				it's a custom element. To ensure backwards compatability browser vendors have agreed to not use
				dashes in new HMTL tags.</q>

			<div class="code">
				<p>&lt;user-card&gt;&lt;/user-card&gt;</p>
			</div>

			<p>This however won't render anything. If you insert text in the &lt;user-card&gt; element it'll show the
				text but really it'll act as a &lt;span&gt; element. This is because the element is not a defined HTML
				tag and thus unknown to the parser, all unknown tags inherit the properties of a &lt;span&gt; element.
			</p>

			<p>To prevent our custom element from being rendered as a &lt;span&gt; element we have to define it in JS.
				This way the parser will find a definition of the tag and render it with the associated styling.</p>

			<img src="../media/images/custom-element.png" class="screenshot">

			<q>The above image shows how to define a custom element in JS</q>

			<p>Since the custom element is defined in the CustomElements list the parser knows that
				&lt;user-card&gt;&lt;/user-card&gt; should render "Wessel Smit" as defined in the associated UserCard
				class.
			</p>

			<p>The above code is a simple demonstration, you can ofcourse do way more such as applying styling, adding
				addEventListeners etc.</p>
		</section>

		<section>
			<h2>Shadow DOM</h2>

			<p>The Shadow DOM is an encapsulated version of the DOM. This means it's cut off from the normal DOM (also
				called the light DOM).</p>

			<p>The Shadow DOM functions as a sub-DOM tree to the light DOM, it's used to encapsulate markup, styles and
				logic meaning it's used to create self-contained DOM fragments.</p>

			<h3>Using Shadow DOM</h3>

			<p>The following images will demonstrate how to use Shadow DOM, the left side is the code and the right side
				is a preview of what's being rendered.</p>

			<img src="../media/images/code1.png">

			<q>The code above renders a simple paragraph and button, it only uses the Light DOM</q>

			<img src="../media/images/code2.png">

			<q>The code above renders a paragraph and button in both the Shadow and Light DOM</q>

			<p>The light DOM structure now contains the Shadow DOM fragment, the Light DOM now contains a piece of
				Shadow DOM and the structure looks like this:</p>

			<img src="../media/images/code3.png">

			<h3>Shadow DOM use case</h3>

			<p>As mentioned before, the Shadow DOM is used to encapsulate markup, styles and logic. The advantage of
				encapsulation is that after defining the markup, styles and logic they can't be affected outside of the
				Shadow DOM.</p>

			<p>Now that we have some HTML in both DOMs, We apply the following CSS;</p>

			<img src="../media/images/code4.png">

			<q>The above CSS should make all paragraph and button text red. </q>

			<p>In the rendered page only the content from the Light DOM is red. This is because the content from the
				Shadow DOM isn't accessible for the Light DOM.</p>

			<img src="../media/images/preview.png">

			<q>As you can see only the content from the Light DOM is red.</q>

			<p>The content is accessible through JS, but you have to specifically select the ShadowRoot first.</p>

			<div class="code">
				<p>const p = document.querySelector('p:nth-of-type(2)') <span>//Select the 2nd paragraph element</span>
				</p>

				<p>console.log(p)<span>//Returns: null</span></p>
			</div>

			<p>This is because JS doesn't have access to the ShadowRoot, to access the paragraph in the ShadowRoot you
				can't use document. Document is Light DOM only and returns errors in the Shadow DOM. To select elements
				inside the Shadow DOM you have to replace document with the element hosting the ShadowRoot. (In our case
				this is the ShadowDOM constant)
			</p>

			<img src="../media/images/code5.png">
		</section>

		<section>
			<h2>HTML Templates</h2>

			<p>The big advantage of HTML templates is their reusability and their simplicity in your HMTL files.
				Template elements aren't rendered by default, this means you can use them to store markup for later use.
				This prevents the hassle of creating markup in JS.</p>

			<ul>
				<p>The 2 most common use cases fot HTML Templates are</p>
				<li>storing markup which will be rendered at a later point in time</li>
				<li>creating a basic markup foundation which is filled with content in an array iteration</li>
			</ul>

			<p>To show how templates work I'll use a template to render content at a later point in time, this is better
				than the innerHTML and createElement alternatives because it's more secure and better readable.</p>

			<p>First you have to create a template and define the markup inside of it, I'll do that with the following
				HTML in my index.hmtl:</p>

			<img src="../media/images/code6.png">

			<q>The above code is my template, it doesn't get rendered until it's inserted in the DOM using JS</q>

			<p>To render the template we have to insert it into the DOM using JS.</p>

			<img src="../media/images/code7.png">

			<q>The above JS code inserts the template in the DOM</q>

			<p>THe following is being rendered:</p>

			<img src="../media/images/preview2.png">

			<p>However, if you want to use the template multiple times the above code won't work. The appendChild()
				method will only replace the template position in the DOM with the current code.</p>

			<p>To reuse the template you have to create a clone of the template which you insert in the DOM. To create a
				clone we can use the cloneNode() or importNode() method.</p>

			<img src="../media/images/code9.png">

			<q>Through clones you can reuse templates</q>

			<p>With cloning the following HTML is rendered:</p>

			<img src="../media/images/preview3.png">
		</section>

		<section>
			<h2>Conclusion</h2>

			<p>Each web API has it's own powerful use cases, but they can also be used together to create web
				components. Using HTML templates you can bundle markup (also styling and scripting) into one template
				element.</p>

			<p>By defining the template in the Shadow DOM you can encapsulate it and make sure it isn't affected by CSS
				or JS outside the Shadow DOM.</p>

			<p>Custom Elements are used to store everything in a custom tag. This custom element will make your code
				easier to read and can help organize your HTML.</p>
		</section>

		<section>
			<h2>Sources:</h2>

			<ul>
				<li>
					<a href="https://css-tricks.com/an-introduction-to-web-components/" target="_blank">web components
						(css-tricks)</a>
				</li>
				<li>
					<a href="https://www.webcomponents.org/introduction" target="_blank">web components
						(webcomponents)</a>
				</li>
				<li>
					<a href="https://www.youtube.com/watch?v=YBwgkr_Sbx0" target="_blank">web components (google chrome
						developers: youtube)</a>
				</li>
				<li>
					<a href="https://www.youtube.com/watch?v=PCWaFLy3VUo" target="_blank">web components (traversy
						media: youtube)</a>
				</li>
				<li>
					<a href="https://codeburst.io/6-reasons-you-should-use-native-web-components-b45e18e069c2"
						target="_blank">advantages of webcomponents (codeburst)</a>
				</li>
				<li>
					<a href="https://www.html5rocks.com/en/tutorials/webcomponents/customelements/"
						target="_blank">custom elements (html5rocks)</a>
				</li>
				<li>
					<a href="https://developers.google.com/web/fundamentals/web-components/shadowdom"
						target="_blank">shadow dom (google)</a>
				</li>
				<li>
					<a href="https://www.youtube.com/watch?v=mfN-EOkj13Q" target="_blank">html templates (steve griffith
						:youtube)</a>
				</li>
			</ul>
		</section>
	</main>
</body>

</html>