<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href='https://fonts.googleapis.com/css?family=Quicksand' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" href="../styles/detail.css" type="text/css">
	<title>Web Components</title>
</head>

<body>
	<header>
		<a id="back-button" href="../index.html"><span></span></a>

		<h1>Web Components</h1>
		<h4>Custom Elements, Shadow DOM and HTML Templates</h4>
	</header>

	<main>
		<section>
			<h2>What are Web Components?</h2>

			<p>Using multiple web API's and technologies you can create create custom, reusable, encapsulated HTML tags,
				these are called web components (WC). If you are familiar with HTML you know the language consists of
				<a href="https://www.w3schools.com/tags/default.asp" target="=_blank">tags</a>. All tags have their own
				uses, behaviour and can differ in basic styling.</p>

			<p>All the relied upon API's and technologies can also be used individually, they all have their own unique
				use-cases.</p>

			<p>In HTML you can also create your own tags by wrapping it in tags, for example;
				&lt;test&gt; or &lt;example&gt;. These 'custom' elements all function the same because undewater they
				are actually span tags/elements.</p>

			<q>&lt;example&gt; is more like a semi-custom element; it has it's own tag but behaves and looks like a
				&lt;span&gt; element. Custom Elements are defined in JS and can then be used in HTML.</q>

			<p>Web Components allows us to create custom elements and assign markup, styling and behaviour. This way
				your custom elements have markup, a basic styling and behaviour without stylesheets or scripts.</p>
		</section>

		<section>
			<h2>Drawing a comparison from Web Components to HTML</h2>

			<p>WC are essentially custom defined HTMl tags which come with their own standard styling and behaviour.
				This basic styling is defined in the code where the WC is created.</p>

			<p>You could look at standard HTMl tags as custom elements defined by the W3C.</p>

			<p>Take the &lt;h2&gt; element for example. Without applying custom CSS rules or scripting it's: black,
				bold, has a custom font-size and custom margin.</p>

			<p>The &lt;video&gt; element also has custom attributes such as: autoplay, controls, loop, muted, poster and
				preload. What these attributes do, how they work etcetera is all defined somewhere but it's not
				accessible for us developers (we can only overwrite it if necessary).</p>
		</section>

		<section>
			<h2>Advantages of Web Components</h2>

			<ul>
				<li>WC can be reused as much as you want to, you only have to define them once.</li>
				<li>WC code/logic is encapsulated, it uses a private scope which means it isn't accessible in the global
					scope/DOM.</li>
				<li>WC only require basic HTML, CSS and JS. It's future proof and compatible with frameworks.</li>
			</ul>

			<ul>
				<p>WC also improve the maintenance and readability of your code;</p>

				<li>Code and logic is contained in one area. Apps are compartmentalized into smaller chunks instead of
					one big file.</li>
				<li>Custom elements allow for custom tag names, which makes it easier to read HTML and determine
					which element does what:</li>
			</ul>

			<div class="code">
				<p>&lt;div id="image-carousel"&gt;&lt;/div&gt; <span>//Standard HTML</span></p>

				<p><span>//Is better readable as:</span></p>

				<p>&lt;image-carousel&gt;&lt;/image-carousel&gt; <span>//Custom Element</span></p>
			</div>

		</section>

		<section>
			<h2>The Web Component building blocks</h2>

			<p>As mentioned before, WC rely on a few web API's and technologies. All these API's and technologies can
				be used on their own (and have their own use-cases) but when used together they create web components.
			</p>
		</section>

		<section>
			<h2>Custom Elements</h2>

			<p>Custom Elements are HTML tags defined by you. You can name them, give them custom markup, styling and
				scripts.</p>

			<p>to create a basic custom element you need atleast HTML and JS.</p>

			<p>In the HTML you need to insert your custom element.</p>

			<q>NOTE: all custom elements need to contain a dash (-) in their name. This is for the parser to indicate
				it's a custom element. To ensure backwards compatability browser vendors have agreed to not use
				dashes in new HMTL tags.</q>

			<div class="code">
				<p>&lt;user-card&gt;&lt;/user-card&gt;</p>
			</div>

			<p>This however won't render anything. If you insert text in the &lt;user-card&gt; element it'll show the
				text but really it'll act as a &lt;span&gt; element. This is because the element is not a defined HTML
				tag and thus unknown to the parser, all unknown tags inherit the properties of a &lt;span&gt; element.
			</p>

			<p>To prevent our custom element from being rendered as a &lt;span&gt; element we have to define it in JS.
				This way the parser will find a definition of the tag and render it with the associated styling.</p>

			<img src="../media/images/gh1.png">

			<q>The above image shows how to define a custom element in JS</q>

			<p>Since the custom element is defined in the CustomElements list the parser knows that
				&lt;user-card&gt;&lt;/user-card&gt; should render "Wessel Smit" as defined in the associated UserCard
				class.
			</p>

			<p>The above code is a simple demonstration, you can ofcourse do way more such as applying styling, adding
				addEventListeners etc.</p>
		</section>

		<section>
			<h2>Shadow DOM</h2>

			<p>The Shadow DOM is an encapsulated version of the DOM. This means it's cut off from the normal DOM (also
				called the light DOM).</p>

			<p>The advantage of using the Shadow DOM is that it's content is seperated/inaccessible we call this
				encapsulated. Basically the Shadow DOM is more difficult to access and is helpful for creating a
				component and prevent it from inheriting styles or logic from other elements.</p>

			<p>It's really difficult to directly manipulate an element in the Shadow DOM outside of the Shadow DOM code.
				Styles have to be written in the Shadow DOM itself or the Shadow DOM needs to contain a link to the
				Light DOM styling. (NOTE: Shadow DOM content does inherit properties from their parent elements in the
				Light DOM)</p>

			<p>The Shadow DOM functions as a sub-DOM tree to the light DOM, it's used to encapsulate markup, styles and
				logic meaning it's used to create self-contained DOM fragments.</p>

			<h3>Using Shadow DOM</h3>

			<p>The following images will demonstrate how to use Shadow DOM, the left side is the code and the right side
				is a preview of what's being rendered.</p>

			<img src="../media/images/code1.png">

			<q>The code above renders a simple paragraph and button, it only uses the Light DOM</q>

			<img src="../media/images/code2.png">

			<q>The code above renders a paragraph and button in both the Shadow and Light DOM</q>

			<p>The light DOM structure now contains the Shadow DOM fragment, the Light DOM now contains a piece of
				Shadow DOM and the structure looks like this:</p>

			<img src="../media/images/code3.png">

			<h3>Shadow DOM use case</h3>

			<p>As mentioned before, the Shadow DOM is used to encapsulate markup, styles and logic. The advantage of
				encapsulation is that after defining the markup, styles and logic they can't be affected outside of the
				Shadow DOM.</p>

			<p>Now that we have some HTML in both DOMs, We apply the following CSS;</p>

			<img src="../media/images/gh2.png">

			<q>The above CSS should make all paragraph and button text red. </q>

			<p>In the rendered page only the content from the Light DOM is red. This is because the content from the
				Shadow DOM isn't accessible for the Light DOM.</p>

			<img src="../media/images/preview.png">

			<q>As you can see only the content from the Light DOM is red.</q>

			<p>The content is accessible through JS, but you have to specifically select the ShadowRoot first.</p>

			<img src="../media/images/gh3.png">


			<p>This is because JS doesn't have access to the ShadowRoot, to access the paragraph in the ShadowRoot you
				can't use document. Document is Light DOM only and returns errors in the Shadow DOM. To select elements
				inside the Shadow DOM you have to replace document with the element hosting the ShadowRoot. (In our case
				this is the ShadowDOM constant)
			</p>

			<img src="../media/images/gh4.png">
		</section>

		<section>
			<h2>HTML Templates</h2>

			<p>The big advantage of HTML templates is their reusability and their simplicity in your HMTL files.
				Template elements aren't rendered by default, this means you can use them to store markup for later use.
				This prevents the hassle of creating markup in JS.</p>

			<ul>
				<p>The 2 most common use cases fot HTML Templates are</p>
				<li>storing markup which will be rendered at a later point in time</li>
				<li>creating a basic markup foundation which is filled with content in an array iteration</li>
			</ul>

			<p>To show how templates work I'll use a template to render content at a later point in time, this is better
				than the innerHTML and createElement alternatives because it's more secure and better readable.</p>

			<p>First you have to create a template and define the markup inside of it, I'll do that with the following
				HTML in my index.hmtl:</p>

			<img src="../media/images/gh5.png">

			<q>The above code is my template, it doesn't get rendered until it's inserted in the DOM using JS</q>

			<p>To render the template we have to insert it into the DOM using JS.</p>

			<img src="../media/images/gh6.png">

			<q>The above JS code inserts the template in the DOM</q>

			<p>THe following is being rendered:</p>

			<img src="../media/images/preview2.png">

			<p>However, if you want to use the template multiple times the above code won't work. The appendChild()
				method will only replace the template position in the DOM with the current code.</p>

			<p>To reuse the template you have to create a clone of the template which you insert in the DOM. To create a
				clone we can use the cloneNode() or importNode() method.</p>

			<img src="../media/images/gh7.png">

			<q>Through clones you can reuse templates</q>

			<p>With cloning the following HTML is rendered:</p>

			<img src="../media/images/preview3.png" height="500px">
		</section>

		<section>
			<h2>Putting it all together</h2>

			<p>No that I've briefly explained the building blocks for web components and their individual uses, let's
				examine a example.</p>

			<p>The following web component is to show urgent-announcements in a new project of mine. It looks like this:
			</p>

			<img src="../media/images/education-portal.png" height="500px">

			<img src="../media/images/urgent-announcement.png">

			<q>Above is the UI and the urgent-announcement web component</q>

			<p>The web component is a notification which shows up at the top of the page. It has a message and close
				button; clicking the close button hides the notification.</p>

			<h3>How does it work?</h3>

			<h5>Creating the template</h5>

			<p>First I created a template, this contains the styling and markup.</p>

			<img src="../media/images/wc.png">

			<q>This code contains the styling and markup (HTML) for the web component</q>

			<p>Other styling such as the custom font used in the component are inherited from the parent elements. This
				is useful because without it we'd have to @font-face it again only to use it in the web component, which
				would just be a waste of data.</p>

			<h5>Defining the template as a custom element</h5>

			<p>To be able to put the webcomponent in our HTML we'd have to define it as a custom element. To do this we
				create a class which we define in the window's customElements property.</p>

			<img src="../media/images/defineCE.png">

			<q>Regsiter the custom element as &lt;urgent-announcement&gt;</q>

			<p>After registering the class as a custom element we can use it in HTML, however the element as of yet is
				completely empty.</p>

			<h5>Initializing the web component</h5>

			<p>The zero state of the component is empty and hidden, the markup and styling in the template however will
				show whenever the element is inserted into the DOM. We also want the web component to live in the Shadow
				DOM instead of the Light DOM.</p>

			<p>We do this in the constructor() which is only used whenever the web component is Initialized. Always call
				super() first to inherit all properties of the class you're extending!</p>

			<p>First we want to attach a shadowDOM to the custom element. Then we clone and insert the content of our
				template into the web component, lastly we set the textContent of the notification (there is no content
				as of yet so it'll insert "").</p>

			<img src="../media/images/wc5.png">

			<h5>Receiving new data from the server</h5>

			<p>I wanted an element which updates itself with the data it receives from the server. So I use
				<a href="https://socket.io/index.html" target=_blank>socketIO</a> to send data to the clients without
				refreshing the page.
			</p>

			<img src="../media/images/code10a.png">


			<p>The above code is the HTML code, it's the registered custom element called urgent-announcement. It has a
				message
				attribute which contains the message it displays and it has an uid attribute to identify the
				notification.</p>

			<p>On the clientside I listen to the urgent-announcement event which is emitted by the server whenever it
				sends data, when it receives a notification this function triggers. It then overwrites the message & uid
				attribute values with the content of the new data.</p>

			<img src="../media/images/code11.png">

			<q>The above endpoint receives data from the server</q>

			<p>The displaying of the message & keeping track of show/hide state is done in the web component itself
				(encapsulated in the Shadow DOM).</p>

			<h5>Updating the web component</h5>

			<p>Whenever the server has a new notification it gets sent to the client using socketIO. On the client the
				urgent-announcement element message & uid attributes are overwritten with the new data from the server.
			</p>

			<p>Inside the custom element we want to trigger an update whenever the client receives new data. Since our
				function updates the message & uid properties we can simply watch these attributes in our class.</p>

			<img src="../media/images/wc1.png">

			<p>The observedAttributes() method watches the passed attributes, in our case we only watch uid (we
				deliberately don't watch messagage because this would trigger everything twice).</p>

			<p>Whenever one of the observed attributes is changed the attributeChangedCallback gets invoked. In here we
				can control what actions we want to undertake.
			</p>

			<img src="../media/images/wc3.png">

			<q>Watch for changes and invoke methods to reflect the attribute changes in the UI</q>

			<p>We use methods to manipulate the web component, all methods use the 'this' keyword which references the
				webcomponent host (&lt;urgent-announcement&gt;).
			</p>

			<img src="../media/images/wc4.png">

			<q>Add methods to: update the content, show and hide the component respectively</q>

			<p>The only thing we have't done is listening to the close button events, we need to know if people have
				clicked to dismiss the notification.</p>

			<p>We can add an eventListener in the construcor(), when triggered we hide the web component.</p>

			<q>NOTE: we could've also used the connectedCallback to add EventListeners, and the disconectedCallback to
				remove the eventListener.</q>

			<img src="../media/images/wc6.png">

			<details>
				<summary>Full Web component code</summary>
				
				<p>NOTE: added some extra logic to the component to also keep track of dismissed/read notification in localStorage.</p>

				<img src="../media/images/socket.png">

				<img src="../media/images/wc7.png">
				<img src="../media/images/wc8.png">

			</details>
		</section>

		<section>
			<h2>Conclusion</h2>

			<p>Each web API has it's own powerful use cases, but they can also be used together to create web
				components. Using HTML templates you can bundle markup (also styling and scripting) into one template
				element.</p>

			<p>By defining the template in the Shadow DOM you can encapsulate it and make sure it isn't affected by CSS
				or JS outside the Shadow DOM.</p>

			<p>Custom Elements are used to store everything in a custom tag. This custom element will make your code
				easier to read and can help organize your HTML.</p>
		</section>

		<section>
			<h2>Sources:</h2>

			<ul>
				<li>
					<a href="https://css-tricks.com/an-introduction-to-web-components/" target="_blank">web components
						(css-tricks)</a>
				</li>
				<li>
					<a href="https://www.webcomponents.org/introduction" target="_blank">web components
						(webcomponents)</a>
				</li>
				<li>
					<a href="https://www.youtube.com/watch?v=YBwgkr_Sbx0" target="_blank">web components (google chrome
						developers: youtube)</a>
				</li>
				<li>
					<a href="https://www.youtube.com/watch?v=PCWaFLy3VUo" target="_blank">web components (traversy
						media: youtube)</a>
				</li>
				<li>
					<a href="https://codeburst.io/6-reasons-you-should-use-native-web-components-b45e18e069c2"
						target="_blank">advantages of webcomponents (codeburst)</a>
				</li>
				<li>
					<a href="https://www.html5rocks.com/en/tutorials/webcomponents/customelements/"
						target="_blank">custom elements (html5rocks)</a>
				</li>
				<li>
					<a href="https://developers.google.com/web/fundamentals/web-components/shadowdom"
						target="_blank">shadow dom (google)</a>
				</li>
				<li>
					<a href="https://www.youtube.com/watch?v=mfN-EOkj13Q" target="_blank">html templates (steve griffith
						:youtube)</a>
				</li>
			</ul>
		</section>
	</main>
</body>

</html>
